\newpage
\section{Opis metod programowania}
{

    \subsection{Języki programowania}
    {
        Python i C++ to dwa języki programowania ogólnego przeznaczenia, które są najczęściej wykorzystywane w robotyce. Python posłużył w pracy jako język, w którym odbywa się implementacja wstępnego rozwiązania, spełniającego wszystkie jego podstawowe funkcjonalności. Z drugiej strony język C++ zapewnia statyczne typowanie, co chroni przed przypadkowym niedopasowaniem typów. Język C++ sprawdza się w przypadku, gdy implementowane rozwiązanie musi charakteryzować się większą wydajnością względem Pythona. Wynika to z faktu, że jest to język kompilowany, a także oferuje niskopoziomowy dostęp do pamięci. Z kolei Python jest językiem, który umożliwia szybsze prototypowanie i pozwala na szybkie tworzenie aplikacji do rozwiązywania złożonych zadań w krótszym czasie. Dodatkowo Python jest językiem interpretowanym, który posiada duży zbiór bibliotek, dzięki czemu nadaje się do różnych celów, takich jak uczenie maszynowe, tworzenie stron internetowych i skryptów. Tak więc zarówno Python, jak i C++ mają swoje zalety i wady, gdy są używane w programowaniu robotyki i mogą być używane w zależności od sytuacji.
    }

    \subsection{Przegląd architektur oprogramowania}
    {
        
        \subsubsection{Oprogramowanie zorientowane na mikroserwisy}
        {
        Oprogramowanie zorientowane na mikroserwisy definiuje się jako takie, które zamiast jednego procesu (tzw. monolitu) wykorzystuje kilka małych procesów \cite{microservices}, gdzie każdy inny jest odpowiedzialny za inne zadanie. Procesy komunikują wykorzystując mechanizmy komunikacji międzyprocesowej. Jest to spowodowane tym, że wygodne jest przekształcenie kombinacji adresu IP~oraz~portu na nazwę, co ułatwia komunikację i pozwala na automatyczne uniknięcie kolizji. 
        
        Zalety takiego podejścia \cite{microservices}:
        \begin{itemize}
            \item Ułatwia ono opracowywanie oprogramowania w zespole. Każda osoba pracuje nad jednym procesem.
            \item Umożliwia mieszanie technologii i języków programowania.
            \item Pozwala na wytworzenie oprogramowania maksymalnie prostego, czytelnego i dobrze przetestowanego.
            \item W razie potrzeby zmiany implementacji procesu wystarczy tylko go podmienić na inny~z~pozostawieniem takiego samego interfejsu.
            \item Zmiany w jednym procesie nie mają żadnego wpływu na inny proces.
            \item Ułatwia zintegrowanie się z innymi istniejącymi systemami.
            \item Pozwala zminimalizować użycie wielowątkowości, co zmniejsza liczbę błędów.
        \end{itemize}
        
        Wady takiego podejścia:
        \begin{itemize}
            \item Takie podejście w sposób geometryczny zwiększa liczbę połączeń pomiędzy komponentami systemu, zwiększa poziom skomplikowania systemu.
            \item Zwiększa liczbę kombinacji przypadków przy testowaniu oprogramowania.
            \item Następuje zwiększenie zużycia pamięci.
        \end{itemize}
        }
        \subsubsection{Oprogramowanie monolityczne}
        {
            Architektura monolityczna jest typem oprogramowania, gdzie cały kod źródłowy uruchomiony jest jako jeden proces \cite{monolythic}. Takie podejście ma zastosowanie w małych projektach oraz prototypowaniu większych projektów. Podejście to sprawia, że wszystkie usługi i zasoby są osadzone w jednym miejscu. Ta architektura charakteryzuje się brakiem komunikacji międzyprocesowej.

            Zalety takiego podejścia:
            \begin{itemize}
                \item Takie oprogramowanie jest bardzo łatwe do implementacji.
                \item Scentralizowane oprogramowanie charakteryzuje się większą wydajnością. Jest to spowodowane brakiem komunikacji międzyprocesowej.
                \item Oprogramowanie napisane w ten sposób jest łatwe do testowania.
                \item Łatwiejsze jest szukanie błędów, gdyż debugger może dotrzeć do konkretnego miejsca bezpośrednio, co jest niemożliwe w przypadku mikroserwisów.
            \end{itemize}

            Wady takiego podejścia:
            \begin{itemize}
                \item Wykonywanie różnych akcji równolegle wymaga zastosowania wielowątkowości.
                \item Rozwiązanie napisane w taki sposób jest trudne w skalowaniu.
                \item Błędy obecne w jednym module mają wpływ na inne moduły.
                \item Uzależnienie się od wąskiej grupy technologii i języków programowania.
                \item Mała zmiana w kodzie źródłowym wymaga ponownego wdrożenia całej aplikacji na docelową maszynę. 
            \end{itemize}
        }
    } 
}