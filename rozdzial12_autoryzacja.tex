\section{System autoryzacji i zarządzania użytkownikami}
\label{chap:autoryzacja}

Opracowany system analizy danych w czasie rzeczywistym wykorzystuje nowoczesny mechanizm autoryzacji oparty na tokenach \mbox{\textit{JWT}} (\mbox{\textit{JSON Web Token}} - standard bezpiecznego przekazywania informacji) zaimplementowany z użyciem serwera \textit{Keycloak} jako dostawcy tożsamości. Takie rozwiązanie zapewnia bezpieczny dostęp do zasobów systemu oraz umożliwia skalowalne zarządzanie użytkownikami i rolami.

\subsection{Architektura systemu autoryzacji}

Serwer \textit{Keycloak} pełni rolę centralnego serwera uwierzytelnienia, zarządzając procesami logowania, wydawania tokenów oraz kontroli dostępu. Aplikacja front-endowa komunikuje się bezpośrednio z nim w celu uzyskania tokenów dostępu, które następnie są wykorzystywane do autoryzacji żądań kierowanych do usług back-endowych poprzez aplikację \textit{FrontService} - bramę API działającą w architekturze mikroserwisowej.

FrontService stanowi centralny punkt dostępu do całego klastra mikroserwisów, implementując jednolity system autoryzacji dla wszystkich usług back-endowych. Dzięki tej architekturze, każdy mikroserwis w klastrze może polegać na walidacji tokenów przeprowadzonej przez bramę, co upraszcza implementację autoryzacji w poszczególnych serwisach oraz zapewnia spójność mechanizmów bezpieczeństwa w całym systemie.

Back-end opracowanej aplikacji został skonfigurowany do pracy w trybie hybrydowym - może działać zarówno z serwerem \textit{Keycloak} jako zewnętrznym dostawcą uwierzytelnienia, jak i z własnym wewnętrznym systemem \mbox{\textit{JWT}} (ang. \mbox{\textit{JSON Web Token}}). Konfiguracja ta jest kontrolowana przez parametr \textit{app.security.useKeycloak}, co zapewnia elastyczność wdrożenia aplikacji w różnych środowiskach.

\subsection{Implementacja po stronie front-endu}

Aplikacja front-endowa wykorzystuje bibliotekę \textit{keycloak-js} do integracji z serwerem \textit{Keycloak}. Konfiguracja połączenia jest realizowana przez zmienne środowiskowe określające URL serwera, nazwę grupy oraz identyfikator klienta. System automatycznie przekierowuje użytkowników do strony logowania serwera \textit{Keycloak} w przypadku braku ważnego tokenu dostępu.

Po pomyślnym uwierzytelnieniu, aplikacja automatycznie dołącza token Bearer do nagłówka \textit{Authorization} wszystkich żądań \textit{HTTP} (ang. \mbox{\textit{Hypertext Transfer Protocol}}) kierowanych do interfejsu API. Implementacja obejmuje mechanizm automatycznego odświeżania tokenów, sprawdzający ważność tokenu przed każdym żądaniem i w razie potrzeby odnawia go w sposób przezroczysty dla użytkownika.

Interface \textit{KeycloakInterface} zapewnia zunifikowany interfejs API do zarządzania sesją użytkownika, sprawdzania ról oraz wykonywania operacji logowania i wylogowania. Implementacja ta abstrahuje szczegóły komunikacji z serwerem \textit{Keycloak}, ułatwiając integrację z komentami biblioteki \textit{React}.

\subsection{Autoryzacja po stronie back-endu}

Aplikacja \textit{FrontService} implementuje wielowarstwowy system autoryzacji wykorzystujący bibliotekę \mbox{\textit{Spring Security WebFlux}} w trybie \textit{Keycloak}. System wykorzystuje mechanizm protokołu \textit{OAuth2 Resource Server} do walidacji tokenów \mbox{\textit{JWT}} wydanych przez serwer uwierzytelnienia. Tokeny są weryfikowane pod kątem poprawności podpisu, ważności czasowej oraz uprawnień użytkownika.

Ekstraktor uprawnień \textit{KeycloakGrantedAuthoritiesConverter} analizuje strukturę tokenu \mbox{\textit{JWT}} w celu pobrania ról zarówno z poziomu grupy, jak i klienta. Umożliwia to precyzyjne mapowanie uprawnień serwera \textit{Keycloak} na role używane wewnętrznie przez aplikację. Opracowany system rozpoznaje hierarchię uprawnień, gdzie role grupy mają wyższy priorytet niż role specyficzne dla klienta.

\subsection{Model uprawnień}

Opracowany system definiuje dwie podstawowe role użytkowników: \textit{DATA\_ACCESSOR} oraz \textit{ADMIN}. Użytkownicy z rolą \textit{DATA\_ACCESSOR} mają dostęp do funkcji odczytu i analizy danych, obejmujących przeglądanie raportów, panelu sterowania oraz konfiguracji systemu. Rola \textit{ADMIN} rozszerza te uprawnienia o możliwość zarządzania użytkownikami, modyfikacji konfiguracji systemu oraz dostępu do funkcji administracyjnych.

Kontrola dostępu jest implementowana na poziomie endpointów API poprzez adnotacje Spring Security. Ścieżki publiczne, takie jak: endpointy healthcheck, są dostępne bez uwierzytelnienia, podczas gdy zasoby biznesowe wymagają odpowiednich ról. Opracowany system automatycznie zwraca kod odpowiedzi HTTP 401 dla żądań bez ważnego tokenu oraz 403 dla żądań z niewystarczającymi uprawnieniami.

\subsection{Zarządzanie użytkownikami}

Proces zarządzania kontami użytkowników odbywa się centralnie przez panel administracyjny serwera Keycloak. Administratorzy systemu mają wyłączną kontrolę nad tworzeniem nowych kont użytkowników, przypisywaniem ról oraz zarządzaniem uprawnieniami dostępu. Takie podejście zapewnia pełną kontrolę nad bezpieczeństwem systemu oraz eliminuje ryzyko związane z samorejestracją użytkowników. Administrator może definiować szczegółowe profile użytkowników, ustalać zasady haseł oraz kontrolować aktywność kont. 

\subsection{Bezpieczeństwo i zarządzanie sesjami}

Implementacja uwzględnia współczesne standardy bezpieczeństwa aplikacji webowych. Tokeny typu JWT (ang. \textit{\mbox{\textit{JSON Web Token}}}) mają ograniczony czas życia, co minimalizuje ryzyko w przypadku ich kompromitacji. System automatycznie czyści tokeny z pamięci przeglądarki po wylogowaniu użytkownika oraz implementuje mechanizmy ochrony przed atakami typu CSRF (ang.~\textit{\mbox{\textit{Cross-Site Request Forgery}}}) poprzez odpowiednią konfigurację nagłówków CORS \\ (ang.~\textit{\mbox{\textit{Cross-Origin Resource Sharing}}}).

Aplikacja FrontService implementuje dodatkowe mechanizmy bezpieczeństwa, w tym ograniczenie liczby prób logowania z określonego adresu IP za pomocą cache-a biblioteki Caffeine. Konfiguracja ta chroni system przed atakami typu brute force poprzez czasowe blokowanie adresów IP po przekroczeniu limitu nieudanych prób uwierzytelnienia.

Zarządzanie błędami autoryzacji jest zunifikowane, zapewniając spójne komunikaty błędów oraz odpowiednie kody odpowiedzi HTTP niezależnie od źródła błędu uwierzytelnienia czy autoryzacji.