\newpage
\section{Środowisko ROS}
{
    % \large
    \subsection{Opis środowiska ROS}
    {
        Roboting Operating System to zestaw pakietów oprogramowania, które stosuje się w robotyce \cite{ros}. Wszystkie jego pakiety są całkowicie otwartoźródłowe. Pakiety tego oprogramowania często są abstrakcyjnymi interfejsami pośredniczącymi pomiędzy sprzętem a kodem wysokopoziomowym. ROS nie jest systemem operacyjnym, mimo że tworzy własne środowisko w systemie operacyjnym, jest tylko zestawem pakietów i bibliotek.

        Powstał on z myślą o tym, by oferować rozwiązania wielu problemów spotykanych w robotyce  w postaci gotowych dobrze przetestowanych pakietów. Skraca to czas implementacji rozwiązania z zakresu robotyki. Istnieje duża liczba pakietów, które potrafią same obsłużyć sprzęt, wystawić lub przyjmować dane czytelne i zrozumiałe dla człowieka.
        
        Oferuje on takie użyteczne pakiety jak na przykład:
        \begin{itemize}
            \item Pakiet \textbf{message\_filters} służy do filtrowania wiadomości. Pozwala on na szeregowanie filtrów, tworząc zestaw filtrów.
            \item Pakiet \textbf{laser\_geometry} służy do obsługi skanów z laserowych czujników odległości.
            \item Pakiet \textbf{urdf} pozwala budować roboty w symulacji. Jest to rozbudowany pakiet, który zawiera wystarczającą ilość możliwości, by zbudować symulację dowolnego robota mobilnego.
            \item Pakiet \textbf{image\_transport} pozwala w wydajny sposób transportować zdjęcia za pomocą protokołu TCP/IP.
            \item Pakiet \textbf{dynamixel\_sdk} służy do sterowania serwomechanizmami. Zapewnia on interfejs przystosowany do środowiska ROS, który w wygodny sposób pozwala na sterowanie  wspomnianymi silnikami.
        \end{itemize}
        
        ROS działa w architekturze mikroserwisowej \cite{microservices}. Uruchomione procesy mogą być przedstawione w postaci grafu. Oprogramowanie wytwarza się w postaci węzłów (ang. \textit{nodes}), które komunikują się między sobą.
        
        Komunikacja przebiega za pomocą wykorzystania modelu TCP/IP \cite{tcpip} oraz gniazd opisanych w rozdziale \ref{sock_desc}. Adres IP maszyny oraz numery portów są konwertowane na nazwę węzła, dzięki czemu użytkownik nie musi zarządzać samodzielnie architekturą sieciową na swojej maszynie. ROS pozwala również na komunikację pomiędzy kilkoma maszynami, wystarczy wystawić główny węzeł (roscore) na jednej maszynie i przekazać informację do drugiej, gdzie on się znajduje, podając adres IP i numer portu.
        
        Komunikacja odbywa się na trzy główne sposoby:
        \begin{itemize}
            \item tematów (ang. \textit{topics}),
            \item serwisów,
            \item akcji.
        \end{itemize}
        
        Tematy (ang. \textit{topics}) \cite{ros_topics} są najprostszą metodą komunikacji. Służą do wymiany wiadomości. Działają na podstawie modelu publisher -- subscriber, gdzie jedne węzły nasłuchują danego tematu, a inne publikują na niego wiadomości. Jest to kierunkowa metoda komunikacji. Każdy temat~ma~swoją nazwę, po której można go znaleźć oraz swój format wiadomości np. int32.

        Serwisy \cite{ros_services} działają na zasadzie zapytania oraz odpowiedzi. Jest to  synchroniczny sposób komunikacji pomiędzy węzłami, gdzie jeden wysyła zapytanie i~żąda również odpowiedzi. Przykładowo możemy zażądać od sterownika silnika krokowego o obrót 5$^o$ w prawo, a w odpowiedzi dostaniemy ilość czasu, jaką zajął ten obrót w sekundach. Serwisy również mają swoje typy~oraz~nazwy tak samo, jak tematy.
        
        Akcje \cite{ros_actionlib} są najbardziej rozbudowanym sposobem komunikacji pomiędzy węzłami. Są podobne do serwisów. Są asynchroniczne, dzięki czemu węzeł nie będzie skupiony na oczekiwaniu na rezultat tak jak w przypadku serwisów, zatem będzie mógł wykonywać inne zadania w trakcie trwania akcji.
        
        By rozpocząć akcję, trzeba do węzła wysłać tzw. cel (ang. \textit{goal}) do serwera akcji umieszczonego w węźle. W międzyczasie otrzymujemy informację o postępie danej akcji (ang. \textit{feedback}). Na~końcu otrzymujemy rezultat tej akcji. Można akcję przerwać w dowolnym momencie. Wyobraźmy sobie robota wyposażonego w skaner laserowy. I chcemy, by skanował nam pokój przez 5 minut. Przykładem celu może być wysłanie do robota celu w postaci czasu skanowania (5 minut). Dane~o~postępie mogą być wysyłane, co sekundę w postaci aktualnej mapy otoczenia, a rezultatem może być~to,~czy~akcja przebiegła pomyślnie.
        
        Poniższy schemat przedstawia jak przebiega komunikacja w trakcie wykonywania akcji.
        
        \singlesizedurlimage{images/actions.png}{Schemat działania klienta oraz serwera akcji} {1.0}{\cite{ros_actionlib}}
        
        ROS zawiera predefiniowane zestawy najczęściej wykorzystywanych typów \cite{types}  wiadomości (np. Float32, String, LaserScan), serwisów oraz akcji. Formaty wiadomości mogą być również definiowane przez użytkownika w plikach .msg, .srv oraz .action.
        
        \newpage
        Poniżej przedstawiono przykłady formatów wiadomości.
        
        \begin{lstlisting}[caption=Przykładowy plik wiadomości tematu .msg]
            uint32 x
            int32 y
        \end{lstlisting}
        
        \begin{lstlisting}[caption=Przykładowy plik wiadomości serwisu .srv]
            int64 first
            int64 second
            ---
            int64 sum
        \end{lstlisting}
        
        \begin{lstlisting}[caption=Przykładowy plik akcji .action]
            #goal
            uint64 count
            ---
            #result
            uint64 result
            ---
            #feedback
            uint64 current_number
        \end{lstlisting}
        
        Jeśli chodzi o publikację wiadomości, to ROS charakteryzuje się dość krótkimi opóźnieniami. Oprogramowanie wykorzystujące ROS'a i jego pakiety może być napisane~w~kilku językach programowania, najpopularniejsze to C++ oraz Python.
    }
    \subsection{Opis wymagań dla środowiska ROS}
    {
        ROS wymaga systemu operacyjnego z rodziny Linux, a szczególnie pochodnych Debiana. Można go uruchomić na komputerach z procesorem x86, x64 lub ARM. Czyli można również go uruchomić na komputerze jednopłytkowym Rapsberry Pi, co idealnie nadaje się do zastosowania~w~małych robotach mobilnych.
    }
    % \subsection{Opis rodziny systemów operacyjnych Linux}
    % {
        
    % }
    \subsection{ROS w porównaniu do systemu RTOS}
    {
        Systemy RTOS\footnote{Real Time Operating System} z reguły wymagają od swoich aplikacji, by uwzględniały reguły pracy w czasie rzeczywistym \cite{rtos}. Systemy RTOS są zwykle niskopoziomowe tzw. \textit{bare metal}. W tych systemach ramy czasowe wykonania danej operacji są ściśle określone, niedopuszczalne jest przekroczenie zadeklarowanej wielkości opóźnień.

        ROS, jako że działa pod systemem linuksowym nie zapewnia wykonania operacji w czasie rzeczywistym, nawet nie gwarantuje wykonania żadnej operacji w zadanym czasie. A to dlatego, że systemy RTOS wykonują dane operacje bezpośrednio na procesorze, nie ma pomiędzy nimi systemu operacyjnego, który zarządza procesami, pamięcią, buforami danych. Mimo że opóźnienia pomiędzy wysłaniem a odebraniem wiadomości są bardzo małe, to jednak istnieją i należy to wziąć pod uwagę podczas implementacji oprogramowania.
        
        Zastosowanie RTOS-a ma pewną znaczącą wadę. Oprogramowanie rozwiązania bazująceg~na~RTOS wymaga bardzo dużo czasu i testowania oraz sprzętu, czyli generuje wysokie koszty.
    }
}