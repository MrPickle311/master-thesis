\section{Generator danych czujników w chmurze}
\label{sec:implementacja_generowania}
\addcontentsline{lof}{section}{Rozdział \ref{sec:implementacja_generowania}}
\addcontentsline{lot}{section}{Rozdział \ref{sec:implementacja_generowania}}

W celu przeprowadzenia kompleksowych testów systemu analizy danych w czasie rzeczywistym, będącego przedmiotem tej pracy, opracowano dedykowany generator danych w chmurze. Generator ten symuluje pracę rzeczywistych urządzeń przemysłowych, generując realistyczne dane sensoryczne z uwzględnieniem korelacji między parametrami oraz ewolucji stanów technicznych urządzeń.

System generatora, który zaimplementowano, został zbudowany w oparciu o architekturę bezserwerową (serverless) w chmurze AWS z wykorzystaniem  funkcji AWS Lambda. Generator produkuje dane dla trzech typów urządzeń przemysłowych: pomp, sprężarek i turbin, symulując cztery rodzaje parametrów sensorycznych: temperaturę, ciśnienie, wibracje oraz wilgotność.

Wartości symulowanych danych są generowane w oparciu o dostarczony wcześniej zbiór z prawdziwych urządzeń przemysłowych. Na tej podstawie w zaimplementowanym rozwiązaniu generowane są przebiegi czasowe dla każdego z czterech parametrów sensorycznych.

\singlesizedimageforced{images/generator_schema.png}{Schemat przepływu danych w generatorze}{1.0}

\subsection{Przygotowanie danych wstępnych do generatora}

Proces przygotowania danych do generatora rozpoczyna się od analizy rzeczywistego przemysłowego zbioru danych za pomocą skryptu opartego na Apache Spark. Zbiór wejściowy zawiera dane sensoryczne z trzech typów urządzeń przemysłowych (pomp, sprężarek i turbin) rozmieszczonych w różnych lokalizacjach fabrycznych.

\subsubsection{Struktura danych wejściowych}

Dane wejściowe składają się z następujących kolumn:
\begin{itemize}
    \item \textbf{temperature} - temperatura urządzenia w stopniach Celsjusza,
    \item \textbf{pressure} - ciśnienie w barach,
    \item \textbf{vibration} - poziom wibracji w jednostkach przyspieszenia,
    \item \textbf{humidity} - wilgotność względna w procentach,
    \item \textbf{equipment} - typ urządzenia (Pump, Compressor, Turbine),
    \item \textbf{location} - lokalizacja fabryczna (Atlanta, Chicago, San Francisco, New York, Houston),
    \item \textbf{faulty} - wskaźnik stanu awaryjnego (0.0 = normalny, 1.0 = awaryjny).
\end{itemize}

\subsubsection{Proces analizy statystycznej}

Skrypt wykonuje wieloetapową analizę danych w następujących krokach:

\begin{itemize}

    \item \textbf{Analiza podstawowych statystyk} - obliczane są podstawowe metryki statystyczne dla każdego typu urządzenia i stanu technicznego:

\begin{itemize}
    \item średnie wartości,
    \item odchylenia standardowe,
    \item wartości minimalne i maksymalne,
    \item liczebności obserwacji.
\end{itemize}

Wyniki są grupowane według kombinacji typu urządzenia i stanu awaryjnego, co pozwala na wyznaczenie charakterystycznych zakresów parametrów dla stanów normalnych i awaryjnych każdego typu urządzenia.

    \item \textbf{Analiza korelacji między sensorami} - skrypt generuje macierze korelacji Pearsona dla różnych kombinacji:
    
\begin{itemize}
    \item \textbf{korelacja ogólna} - dla wszystkich danych,
    \item \textbf{korelacja specyficzna dla urządzeń} - oddzielnie dla każdego typu urządzenia,
    \item \textbf{korelacja specyficzna dla stanów} - oddzielnie dla stanów normalnych i awaryjnych,
    \item \textbf{korelacja kombinowana} - dla każdej kombinacji typu urządzenia i stanu.
\end{itemize}

Dodatkowo obliczana jest macierz zmian korelacji:
$$\Delta\mathbf{R} = \mathbf{R}_{faulty} - \mathbf{R}_{normal},$$ 

pokazująca, jak korelacje między parametrami zmieniają się podczas przejścia ze stanu normalnego do awaryjnego.

    \item \textbf{Analiza głównych składowych (PCA)} - wykonywana jest analiza PCA (ang. Principal Component Analysis) w celu:
    
\begin{itemize}
    \item identyfikacji najważniejszych czynników wpływających na stan urządzeń,
    \item określenia wkładu każdego parametru sensorycznego w główne składowe,
    \item redukcji wymiarowości danych przy zachowaniu maksymalnej wariancji,
    \item wyznaczenia ważności cech (\textit{feature importance}) na podstawie ładunków składowych.
\end{itemize}

\end{itemize}

\subsubsection{Generowane pliki konfiguracyjne}

Wyniki analizy są zapisywane w katalogu \texttt{analysis\_output} w postaci plików wykorzystywanych przez generator:

\paragraph{Pliki statystyk}
\begin{itemize}
    \item statystyki podstawowe dla każdego typu urządzenia,
    \item statystyki dla stanów normalnych i awaryjnych,
    \item statystyki dla kombinacji urządzenie-stan.
\end{itemize}

\paragraph{Pliki korelacji}
\begin{itemize}
    \item macierz korelacji ogólnej,
    \item macierze specyficzne dla urządzeń i stanów,
    \item macierz zmian korelacji,
    \item słownik korelacji w formacie JSON.
\end{itemize}

Powyższe pliki konfiguracyjne stanowią bazę dla generatora danych, zapewniając, że ich symulowacja zachowuje realistyczne charakterystyki statystyczne i korelacyjne obserwowane w rzeczywistych informacjach przemysłowych.

Symulator wykorzystuje wielowymiarowe rozkłady normalne do generowania skorelowanych danych sensorycznych, zachowując realistyczne relacje między parametrami. Przejścia między stanami są modelowane probabilistycznie z określonymi czasami trwania dla każdego stanu.


\subsection{Model matematyczny korelacji}
\label{subsec:model_korelacji}

Generator wykorzystuje macierze korelacji wyznaczone na podstawie analizy informacji historycznych. System automatycznie ładuje macierze korelacji dla różnych kombinacji typów urządzeń i stanów technicznych z plików konfiguracyjnych wygenerowanych przez skrypt analizy.

Dla każdego typu urządzenia $i$ i stanu $s$ dostępne są dedykowane macierze korelacji $\mathbf{R}_{i,s}$:

$$\mathbf{R}_{i,s} = \begin{pmatrix}
1 & r_{12} & r_{13} & r_{14} \\
r_{12} & 1 & r_{23} & r_{24} \\
r_{13} & r_{23} & 1 & r_{34} \\
r_{14} & r_{24} & r_{34} & 1
\end{pmatrix},$$

gdzie $r_{jk}$ oznacza współczynnik korelacji między parametrami $j$ i $k$.

\vspace{0.3em}

Generator implementuje adaptacyjny wybór macierzy korelacji na podstawie aktualnego stanu urządzenia:
\begin{itemize}
    \item dla stanu normalnego: $\mathbf{R}_{i,normal}$,
    \item dla stanów degradacji: progresywne przejście od $\mathbf{R}_{i,normal}$ do $\mathbf{R}_{i,faulty}$,
    \item dla stanu krytycznego: $\mathbf{R}_{i,faulty}$,
    \item dla stanu naprawy: brak generowania danych sensorycznych.
\end{itemize}

\subsection{Algorytm generowania skorelowanych wartości}
\label{subsec:algorytm_generowania}

System implementuje zaawansowany algorytm generowania skorelowanych wartości sensorycznych wykorzystujący wielowymiarowy rozkład normalny z adaptacyjnym mieszaniem statystyk.

\subsubsection{Mieszanie statystyk między stanami}

Dla każdego parametru sensorowego obliczane są mieszane statystyki na podstawie poziomu uszkodzenia $f \in [0, 1]$:

$$\mu_{mieszane}(f) = \mu_{normal} + f \cdot (\mu_{faulty} - \mu_{normal}),$$
$$\sigma_{mieszane}(f) = \sigma_{normal} + f \cdot (\sigma_{faulty} - \sigma_{normal}),$$

gdzie poziom uszkodzenia $f$ jest funkcją stanu i postępu w stanie:

$$f(stan, post\k{e}p) = \begin{cases}
0.0 & \text{dla stanu normalnego} \\
0.2 + 0.2 \cdot post\k{e}p & \text{dla wczesnego zu\.{z}ycia} \\
0.4 + 0.3 \cdot post\k{e}p & \text{dla stanu podkrytycznego} \\
0.7 + 0.3 \cdot post\k{e}p & \text{dla stanu krytycznego} \\
1.0 & \text{dla stanu naprawy}
\end{cases},$$

\subsubsection{Komponenty cykliczne}

System uwzględnia naturalne cykle operacyjne poprzez dodanie komponentów cyklicznych:

$$\mu_{cykliczne} = \mu_{mieszane} + A \cdot \sin\left(\frac{2\pi t}{T}\right),$$

gdzie:
\begin{itemize}
    \item $A = 0.2 \cdot \sigma_{normal}$ - amplituda cyklu dobowego,
    \item $T = 24$ godziny - okres cyklu,
    \item $t$ - aktualny czas w godzinach.
\end{itemize}

\subsubsection{Generowanie wartości z rozkładu wielowymiarowego}

Skorelowane wartości sensoryczne są generowane z wielowymiarowego rozkładu normalnego:

$$\mathbf{x} \sim \mathcal{N}(\boldsymbol{\mu}_{mieszane}, \boldsymbol{\Sigma}),$$

gdzie macierz kowariancji obliczana jest jako:
$$\boldsymbol{\Sigma} = \mathbf{D} \mathbf{R}_{i,s} \mathbf{D},$$

gdzie $\mathbf{D} = \text{diag}(\sigma_1, \sigma_2, \sigma_3, \sigma_4)$ to macierz diagonalna odchyleń standardowych.

\subsection{Wygładzanie czasowe i ograniczenia zmian}
\label{subsec:wygladzanie_czasowe}

Celemem zapewnienia realistycznego przejścia między kolejnymi odczytami, system implementuje dwuetapowe wygładzanie skłądające się z następujących etapów:

\subsubsection{Ograniczenie szybkości zmian}

Maksymalna zmiana między kolejnymi odczytami jest ograniczona do:

$$\Delta x_{max} = \sigma_{normal} \cdot r_{max} \cdot k_{stan},$$

gdzie:
\begin{itemize}
    \item $r_{max} = 0.2$ - maksymalny współczynnik zmiany,
    \item $k_{stan}$ - czynnik stanu (1.0 dla normalnego, 1.5 dla podkrytycznego, 2.0 dla krytycznego).
\end{itemize}

Rzeczywista zmiana wartości danej wielkości pochodzącej z czujnika jest ograniczana zgodnie z:

$$\Delta x_{limited} = \begin{cases}
\Delta x & \text{jeśli } |\Delta x| \leq \Delta x_{max} \\
\Delta x_{max} \cdot \text{sign}(\Delta x) & \text{w przeciwnym przypadku}
\end{cases},$$

\subsubsection{Wygładzanie wykładnicze}

Po przeprowadzeniu ograniczenia szybkości zmian, w kolejnym etapie stosowane jest wygładzanie wykładnicze:

$$x_{t+1} = x_t + (1-\alpha) \cdot \Delta x_{limited},$$

gdzie $\alpha = 0.8$ to współczynnik wygładzania.

\subsection{Model stanów urządzeń i przejść}
\label{subsec:model_stanow}

System implementuje deterministyczny model maszyny stanów z probabilistycznymi czasami trwania.

\subsubsection{Stany techniczne urządzeń}

Generator danych modeluje następujące stany techniczne:

\begin{itemize}
    \item \textbf{stan normalny} - prawidłowa praca urządzenia,
    \item \textbf{wczesne zużycie} - początkowe oznaki degradacji,
    \item \textbf{stan podkrytyczny} - znaczące pogorszenie parametrów,
    \item \textbf{stan krytyczny} - stan przed awarią,
    \item \textbf{naprawa} - okres nieaktywności urządzenia.
\end{itemize}

\subsubsection{Parametry czasowe stanów}

Każdy stan techniczny charakteryzuje się losowym czasem trwania z zakresu $[t_{min}, t_{max}]$, co zostało przedstawione w tabeli \ref{tab:parametry_stanow_sim}:

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|l|}
\hline
\textbf{Stan} & \textbf{Min. czas} & \textbf{Max. czas} & \textbf{Następny stan} \\
\hline
normalny & 24h & 7 dni & wczesne zużycie \\
wczesne zużycie & 12h & 48h & podkrytyczny \\
podkrytyczny & 6h & 24h & krytyczny \\
krytyczny & 1h & 6h & naprawa \\
naprawa & 2h & 4h & normalny \\
\hline
\end{tabular}
\caption{Parametry czasowe stanów urządzeń w symulatorze}
\label{tab:parametry_stanow_sim}
\end{table}

\subsubsection{Deterministyczne przejścia stanów}

System wykorzystuje deterministyczne generowanie czasów trwania stanów na podstawie funkcji \texttt{hash}:

$$t_{stan} = t_{min} + \texttt{hash}(typ\_urzadzenia + stan + timestamp) \bmod (t_{\text{max}} - t_{min}),$$

Zapewnia to powtarzalność generowanych danych przy wykorzystaniu tego samego ziarna losowego.

\subsection{Algorytm generowania danych historycznych}
\label{subsec:algorytm_historycznych}

Generator implementuje algorytm generowania kompletnych szeregów czasowych historycznych z minutową rozdzielczością.

\subsubsection{Inicjalizacja deterministyczna}

Każdy typ urządzenia inicjalizowany jest z deterministycznym stanem początkowym:

$$stan_{poczatkowy} = \begin{cases}
\text{normalny} & \text{je\'sli } h(typ) \bmod 1.0 < 0.5 \\
\text{wczesne zu\.{z}ycie} & \text{je\'sli } 0.5 \leq h(typ) \bmod 1.0 < 0.8 \\
\text{podkrytyczny} & \text{w przeciwnym przypadku}
\end{cases},$$

gdzie $h(typ)$ to funkcja \texttt{hash} typu urządzenia.

\subsubsection{Iteracyjne generowanie danych}

Dla każdego kroku czasowego $t$ (minuty):

\begin{enumerate}
    \item aktualizacja czasu w stanie: $t_{stan} = t_{stan} + \Delta t,$
    \item obliczenie postępu: $progress = \texttt{min}(1.0, t_{stan} / t_{trwania}),$
    \item sprawdzenie konieczności przejścia stanu,
    \item generowanie wartości docelowych z rozkładu wielowymiarowego,
    \item zastosowanie wygładzania czasowego,
    \item zapis danych do pliku CSV.
\end{enumerate}

\subsubsection{Obsługa stanu naprawy}

Podczas stanu naprawy system:
\begin{itemize}
    \item nie generuje wartości sensorycznych (wartości NULL),
    \item zachowuje informacje o stanie i czasie,
    \item po zakończeniu naprawy resetuje wartości do normalnych.
\end{itemize}

\subsubsection{Integracja z chmurą AWS}
\label{sec:integracja_aws}

System generatora danych został zaimplementowany jako w pełni bezserwerowa architektura w chmurze AWS, wykorzystująca funkcję AWS Lambda, usługę Amazon S3 oraz usługę Amazon SNS. Implementacja zapewnia skalowalność, niezawodność oraz efektywność kosztową przy minimalnych wymaganiach administracyjnych.

Generator czyta wcześniej wygenerowane pliki CSV z usługi S3 i generuje dane w odstępach minutowych.

\subsubsection{Architektura bezserwerowa}
\label{subsec:architektura_bezserwerowa}

System składa się z trzech głównych komponentów chmury AWS:

\begin{itemize}
    \item \textbf{usługa Amazon S3} - przechowywanie danych historycznych i metadanych konfiguracyjnych,
    \item \textbf{funkcja AWS Lambda} - funkcja wykonująca logikę publikowania danych w czasie rzeczywistym,
    \item \textbf{usługa Amazon SNS} - tematy publikacyjno-subskrypcyjne dla każdego typu sensora.
\end{itemize}

\subsubsection{Przechowywanie danych w Amazon S3}
\label{subsec:amazon_s3}

System wykorzystuje usługę Amazon S3 jako centralne repozytorium dla danych historycznych wygenerowanych przez symulator lokalny.

\subsubsection{Struktura danych w S3}

Dane są organizowane w następującej strukturze:

\begin{itemize}
    \item \textbf{prefiks danych}: \texttt{prod\_data/},
    \item \textbf{pliki CSV}: \texttt{pump\_YYYYMMDD.csv}, \texttt{compressor\_YYYYMMDD.csv}, \texttt{turbine\_YYYYMMDD.csv},
    \item \textbf{metadane}: \texttt{prod\_data/historical\_metadata.json}.
\end{itemize}

Poniższy plik reprezentuje format metadanych zawierający konfigurację systemu w formacie JSON, co zostało przedstawione na listingu \ref{lst:plik_metadanych}:

\begin{lstlisting}[caption=Plik metadanych, label={lst:plik_metadanych}]
{
  "generated_at": "2023-01-15 14:30:00",
  "start_timestamp": 1672531200,
  "end_timestamp": 1675123199,
  "minute_resolution": 1,
  "equipment_types": ["Pump", "Compressor", "Turbine"],
  "sensor_types": ["temperature", "pressure", "vibration", "humidity"],
  "seed": 42,
  "files": {
    "Pump": "pump_20230101.csv",
    "Compressor": "compressor_20230101.csv", 
    "Turbine": "turbine_20230101.csv"
  }
}
\end{lstlisting}

\newpage

\subsubsection{Funkcja AWS Lambda}
\label{subsec:aws_lambda}

Główna logika systemu jest zaimplementowana jako funkcja AWS Lambda napisana w języku Python z wykorzystaniem bibliotek: boto3, pandas oraz pydantic. System wykorzystuje bibliotekę Pydantic do walidacji i serializacji danych, co zostało przedstawione na listingu \ref{lst:klasy_modeli_danych}.

\begin{lstlisting}[language=Python, caption=Klasy modeli danych, label={lst:klasy_modeli_danych}]
class SensorData(BaseModel):
    label: str
    timestamp: int
    event_key: str

class Temperature(SensorData):
    temperature: TemperatureData

class Pressure(SensorData):
    pressure: PressureData
\end{lstlisting}

\textbf{Algorytm publikowania danych} - funkcja AWS Lambda wykonuje następujący algorytm przy każdym wywołaniu. Funkcja implementuje algorytm wyszukiwania najbliższego czasowo rekordu, co zostało przedstawione na listingu \ref{lst:algorytm_wyszukiwania_rekordu}. 

\vspace{0.3em}

Składa się z następujących kroków:

\begin{enumerate}
    \item \textbf{ładowanie metadanych} z usługi S3 w celu określenia dostępnych plików z informacjami
    \item \textbf{ładowanie danych} dla każdego typu urządzenia z plików CSV
    \item \textbf{wyznaczenie aktualnego czasu} z zaokrągleniem do pełnej minuty
    \item \textbf{wyszukanie najbliższego rekordu} w danych historycznych dla każdego urządzenia
    \item \textbf{generowanie unikalnych kluczy} zdarzeń dla każdego urządzenia
    \item \textbf{publikowanie danych} do odpowiednich tematów usługi SNS dla każdego sensora
\end{enumerate}

\begin{lstlisting}[language=Python, caption=Algorytm wyszukiwania najbliższego rekordu, label={lst:algorytm_wyszukiwania_rekordu}]
def _find_closest_record(self, df, target_time):
    target_time_dt = pd.to_datetime(target_time)
    df['time_diff'] = abs(df['timestamp'] - target_time_dt)
    closest_record = df.loc[df['time_diff'].idxmin()]
    return closest_record
\end{lstlisting}

\subsubsection{Amazon SNS dla publikowania danych}
\label{subsec:amazon_sns}

System wykorzystuje system transportowania danych Amazon Simple Notification Service (SNS) do asynchronicznego publikowania danych sensorycznych w architekturze publish-subscribe. Każda wiadomość jest publikowana w formacie JSON zgodnym z modelem Pydantic.

\vspace{0.3em}

Dla każdego typu sensora utworzony jest dedykowany temat w usłudze SNS:

\begin{itemize}
    \item \texttt{arn:aws:sns:eu-central-1:accountid:temperature-topic},
    \item \texttt{arn:aws:sns:eu-central-1:accountid:pressure-topic},
    \item \texttt{arn:aws:sns:eu-central-1:accountid:vibration-topic},
    \item \texttt{arn:aws:sns:eu-central-1:accountid:humidity-topic}.
\end{itemize}

\newpage

Format publikowanych wiadomości do systemu SNS został przedstawiony na listingu \ref{lst:format_publikowanych_wiadomosci}.

\begin{lstlisting}[caption=Format publikowanych wiadomości, label={lst:format_publikowanych_wiadomosci}]
{
  "label": "pump",
  "timestamp": 1672531200,
  "event_key": "pump-1672531200",
  "temperature": {
    "temperature": 72.5
  }
}
\end{lstlisting}


System ten stanowi kluczowy element infrastruktury testowej, umożliwiając kompleksową walidację opracowanego systemu analizy danych bez konieczności dostępu do rzeczywistych instalacji przemysłowych oraz zapewniając pełną integrację z ekosystemem chmury AWS.