\section{Generator danych czujników w chmurze}
\label{sec:implementacja_generowania}
\addcontentsline{lof}{section}{Rozdział \ref{sec:implementacja_generowania}}
\addcontentsline{lot}{section}{Rozdział \ref{sec:implementacja_generowania}}
\addcontentsline{lol}{section}{Rozdział \ref{sec:implementacja_generowania}}

\numberwithin{equation}{section}

W celu przeprowadzenia kompleksowych testów opracowanego systemu analizy danych w czasie rzeczywistym, będącego przedmiotem tej pracy, opracowano dedykowany generator danych w chmurze \textbf{AWS}. Symuluje on pracę rzeczywistych urządzeń przemysłowych, generując realistyczne dane sensoryczne z uwzględnieniem korelacji między parametrami oraz ewolucji stanów technicznych urządzeń.

Zaimplementowany generator został zbudowany w oparciu o architekturę bezserwerową (serverless) w chmurze \textbf{AWS} (\mbox{Amazon Web Services}) z wykorzystaniem funkcji \mbox{AWS Lambda} (usługa obliczeń bezserwerowych). Produkuje on dane dla trzech typów urządzeń przemysłowych: pomp, sprężarek i turbin, symulując cztery rodzaje parametrów sensorycznych: temperaturę, ciśnienie, wibracje oraz wilgotność.

Wartości symulowanych danych są generowane w oparciu o dostarczony wcześniej zbiór z prawdziwych urządzeń przemysłowych. Na tej podstawie w zaimplementowanym rozwiązaniu generowane są przebiegi czasowe dla każdego z czterech parametrów sensorycznych. Schemat przepływu danych w generatorze pokazany jest na rysunku \ref{Schemat przepływu danych w generatorze}.

\singlesizedimageforced{images/generator_schema.png}{Schemat przepływu danych w generatorze}{1.0}

\subsection{Przygotowanie danych wstępnych do generatora}

Proces przygotowania danych do generatora rozpoczyna się od analizy rzeczywistego przemysłowego zbioru danych za pomocą skryptu opartego na silniku \mbox{Apache Spark}. Zbiór wejściowy zawiera dane sensoryczne z trzech typów urządzeń przemysłowych (pomp, sprężarek i turbin) rozmieszczonych w różnych lokalizacjach fabrycznych.

\subsubsection{Struktura danych wejściowych}

Dane wejściowe składają się z następujących kolumn:
\begin{itemize}
    \item \textbf{temperature} - temperatura urządzenia w stopniach Celsjusza,
    \item \textbf{pressure} - ciśnienie w barach,
    \item \textbf{vibration} - poziom wibracji w jednostkach przyspieszenia,
    \item \textbf{humidity} - wilgotność względna w procentach,
    \item \textbf{equipment} - typ urządzenia (Pump, Compressor, Turbine),
    \item \textbf{location} - lokalizacja fabryczna (Atlanta, Chicago, San Francisco, New York, Houston),
    \item \textbf{faulty} - wskaźnik stanu awaryjnego (0.0 = normalny, 1.0 = awaryjny).
\end{itemize}

\subsubsection{Proces analizy statystycznej}

Skrypt wykonuje wieloetapową analizę danych w następujących krokach:

\begin{itemize}

    \item \textbf{Analiza podstawowych statystyk} - obliczane są podstawowe metryki statystyczne dla każdego typu urządzenia i stanu technicznego:

\begin{itemize}
    \item średnie wartości,
    \item odchylenia standardowe,
    \item wartości minimalne i maksymalne,
    \item liczebności obserwacji.
\end{itemize}

Wyniki są grupowane według kombinacji typu urządzenia i stanu awaryjnego, co pozwala na wyznaczenie charakterystycznych zakresów parametrów dla stanów normalnych i awaryjnych każdego typu urządzenia.

    \item \textbf{Analiza korelacji między sensorami} - skrypt generuje macierze korelacji Pearsona \cite{pearson_correlation} dla różnych kombinacji:
    
\begin{itemize}
    \item \textbf{korelacja ogólna} - dla wszystkich danych,
    \item \textbf{korelacja specyficzna dla urządzeń} - oddzielnie dla każdego typu urządzenia,
    \item \textbf{korelacja specyficzna dla stanów} - oddzielnie dla stanów normalnych i awaryjnych,
    \item \textbf{korelacja kombinowana} - dla każdej kombinacji typu urządzenia i stanu.
\end{itemize}

Dodatkowo obliczana jest macierz zmian korelacji:
\begin{equation}
\Delta\mathbf{R} = \mathbf{R}_{faulty} - \mathbf{R}_{normal},
\end{equation}

pokazująca, jak korelacje między parametrami zmieniają się podczas przejścia ze stanu normalnego do awaryjnego.

    \item \textbf{Analiza głównych składowych (PCA)} - wykonywana jest analiza PCA (ang. Principal Component Analysis) \cite{jolliffe_pca} w celu:
    
\begin{itemize}
    \item identyfikacji najważniejszych czynników wpływających na stan urządzeń,
    \item określenia wkładu każdego parametru sensorycznego w główne składowe,
    \item redukcji wymiarowości danych przy zachowaniu maksymalnej wariancji,
    \item wyznaczenia ważności cech (\textit{feature importance}) na podstawie ładunków składowych.
\end{itemize}

\end{itemize}

\newpage

\subsubsection{Generowane pliki konfiguracyjne}

Wyniki analizy są zapisywane w katalogu \textit{analysis\_output} w postaci zestawionych poniżej plików wykorzystywanych przez generator.

\vspace{0.3em}

Pliki statystyk zawierają:
\begin{itemize}
    \item statystyki podstawowe dla każdego typu urządzenia,
    \item statystyki dla stanów normalnych i awaryjnych,
    \item statystyki dla kombinacji urządzenie-stan.
\end{itemize}

\vspace{0.3em}

Pliki korelacji zawierają:
\begin{itemize}
    \item macierz korelacji ogólnej,
    \item macierze specyficzne dla urządzeń i stanów,
    \item macierz zmian korelacji,
    \item słownik korelacji w formacie JSON.
\end{itemize}

\vspace{0.3em}

Powyższe pliki konfiguracyjne stanowią bazę dla generatora danych, zapewniając, że ich symulowacja zachowuje realistyczne charakterystyki statystyczne i korelacyjne obserwowane w rzeczywistych informacjach przemysłowych.

Symulator wykorzystuje wielowymiarowe rozkłady normalne do generowania skorelowanych danych sensorycznych, zachowując realistyczne relacje między parametrami. Przejścia między stanami są modelowane probabilistycznie z określonymi czasami trwania dla każdego stanu.


\subsection{Model matematyczny korelacji}
\label{subsec:model_korelacji}

Generator wykorzystuje macierze korelacji wyznaczone na podstawie analizy informacji historycznych. System automatycznie ładuje macierze korelacji dla różnych kombinacji typów urządzeń i stanów technicznych z plików konfiguracyjnych wygenerowanych przez skrypt analizy.

Dla każdego typu urządzenia $i$ i stanu $s$ dostępne są dedykowane macierze korelacji $\mathbf{R}_{i,s}$ :

\begin{equation}
\mathbf{R}_{i,s} = \begin{pmatrix}
1 & r_{12} & r_{13} & r_{14} \\
r_{12} & 1 & r_{23} & r_{24} \\
r_{13} & r_{23} & 1 & r_{34} \\
r_{14} & r_{24} & r_{34} & 1
\end{pmatrix},
\end{equation}

gdzie $r_{jk}$ oznacza współczynnik korelacji między parametrami $j$ i $k$.

\vspace{0.3em}

Generator implementuje adaptacyjny wybór macierzy korelacji na podstawie aktualnego stanu urządzenia:
\begin{itemize}
    \item dla stanu normalnego: $\mathbf{R}_{i,normal}$ ,
    \item dla stanów degradacji: progresywne przejście od $\mathbf{R}_{i,normal}$ do $\mathbf{R}_{i,faulty}$ ,
    \item dla stanu krytycznego: $\mathbf{R}_{i,faulty}$ ,
    \item dla stanu naprawy: brak generowania danych sensorycznych.
\end{itemize}

\subsection{Algorytm generowania skorelowanych wartości}
\label{subsec:algorytm_generowania}

Generator implementuje zaawansowany algorytm generowania skorelowanych wartości sensorycznych wykorzystujący wielowymiarowy rozkład normalny z adaptacyjnym mieszaniem statystyk.

\subsubsection{Mieszanie statystyk między stanami}

Dla każdego parametru sensorowego obliczane są mieszane statystyki na podstawie poziomu uszkodzenia $f \in [0, 1]$:

\begin{equation}
\mu_{mieszane}(f) = \mu_{normal} + f \cdot (\mu_{faulty} - \mu_{normal}),
\end{equation}
\begin{equation}
\sigma_{mieszane}(f) = \sigma_{normal} + f \cdot (\sigma_{faulty} - \sigma_{normal}),
\end{equation}

gdzie:
\begin{itemize}
    \item $\mu_{mieszane}(f)$ - mieszana średnia wartość parametru dla poziomu uszkodzenia $f$,
    \item $\mu_{normal}$ - średnia wartość parametru w stanie normalnym,
    \item $\mu_{faulty}$ - średnia wartość parametru w stanie awaryjnym,
    \item $\sigma_{mieszane}(f)$ - mieszane odchylenie standardowe parametru dla poziomu uszkodzenia $f$,
    \item $\sigma_{normal}$ - odchylenie standardowe parametru w stanie normalnym,
    \item $\sigma_{faulty}$ - odchylenie standardowe parametru w stanie awaryjnym,
    \item $f$ - poziom uszkodzenia w zakresie $[0, 1]$,
\end{itemize}

a poziom uszkodzenia $f$ jest funkcją stanu i postępu w stanie:

\begin{equation}
f(stan, post\k{e}p) = \begin{cases}
0.0 & \text{dla stanu normalnego} \\
0.2 + 0.2 \cdot post\k{e}p & \text{dla wczesnego zu\.{z}ycia} \\
0.4 + 0.3 \cdot post\k{e}p & \text{dla stanu podkrytycznego} \\
0.7 + 0.3 \cdot post\k{e}p & \text{dla stanu krytycznego} \\
1.0 & \text{dla stanu naprawy}
\end{cases},
\end{equation}
gdzie $post\k{e}p$ oznacza postęp czasowy w danym stanie wyrażony w zakresie $[0, 1]$.

\subsubsection{Komponenty cykliczne}

Generator uwzględnia naturalne cykle operacyjne poprzez dodanie komponentów cyklicznych:

\begin{equation}
\mu_{cykliczne} = \mu_{mieszane} + A \cdot \sin\left(\frac{2\pi t}{T}\right),
\end{equation}

gdzie:
\begin{itemize}
    \item $\mu_{cykliczne}$ - średnia wartość z uwzględnieniem cyklu operacyjnego,
    \item $\mu_{mieszane}$ - mieszana średnia wartość bez cyklu,
    \item $A = 0.2 \cdot \sigma_{normal}$ - amplituda cyklu dobowego,
    \item $\sigma_{normal}$ - odchylenie standardowe w stanie normalnym,
    \item $T = 24$ godziny - okres cyklu,
    \item $t$ - aktualny czas w godzinach.
\end{itemize}

\newpage

\subsubsection{Generowanie wartości z rozkładu wielowymiarowego}

Skorelowane wartości sensoryczne są generowane z wielowymiarowego rozkładu normalnego \cite{anderson_mva} :

\begin{equation}
\mathbf{x} \sim \mathcal{N}(\boldsymbol{\mu}_{mieszane}, \boldsymbol{\Sigma}),
\end{equation}

gdzie:
\begin{itemize}
    \item $\mathbf{x}$ - wektor wartości sensorycznych (temperatura, ciśnienie, wibracje, wilgotność),
    \item $\boldsymbol{\mu}_{mieszane}$ - wektor mieszanych średnich wartości,
    \item $\boldsymbol{\Sigma}$ - macierz kowariancji,
\end{itemize}

a macierz kowariancji obliczana jest jako:
\begin{equation}
\boldsymbol{\Sigma} = \mathbf{D} \mathbf{R}_{i,s} \mathbf{D},
\end{equation}

gdzie:
\begin{itemize}
    \item $\mathbf{D} = \text{diag}(\sigma_1, \sigma_2, \sigma_3, \sigma_4)$ - macierz diagonalna odchyleń standardowych ($\sigma_1, \sigma_2, \sigma_3, \sigma_4$ to odchylenia standardowe poszczególnych parametrów),
    \item $\mathbf{R}_{i,s}$ - macierz korelacji dla typu urządzenia $i$ i stanu $s$.
\end{itemize}

\subsection{Wygładzanie czasowe i ograniczenia zmian}
\label{subsec:wygladzanie_czasowe}

Celemem zapewnienia realistycznego przejścia między kolejnymi odczytami, generator implementuje dwuetapowe wygładzanie skłądające się z następujących etapów:

\subsubsection{Ograniczenie szybkości zmian}

Maksymalna zmiana między kolejnymi odczytami jest ograniczona do:

\begin{equation}
\Delta x_{max} = \sigma_{normal} \cdot r_{max} \cdot k_{stan},
\end{equation}

gdzie:
\begin{itemize}
    \item $\Delta x_{max}$ - maksymalna dozwolona zmiana wartości między kolejnymi odczytami,
    \item $\sigma_{normal}$ - odchylenie standardowe w stanie normalnym,
    \item $r_{max} = 0.2$ - maksymalny współczynnik zmiany,
    \item $k_{stan}$ - czynnik stanu (1.0 dla normalnego, 1.5 dla podkrytycznego, 2.0 dla krytycznego).
\end{itemize}

Rzeczywista zmiana wartości danej wielkości pochodzącej z czujnika jest ograniczana zgodnie z regułą:

\begin{equation}
\Delta x_{limited} = \begin{cases}
\Delta x & \text{jeśli } |\Delta x| \leq \Delta x_{max} \\
\Delta x_{max} \cdot \text{sign}(\Delta x) & \text{w przeciwnym przypadku}
\end{cases},
\end{equation}

gdzie:
\begin{itemize}
    \item $\Delta x_{limited}$ - ograniczona zmiana wartości,
    \item $\Delta x$ - pierwotna zmiana wartości,
    \item $\Delta x_{max}$ - maksymalna dozwolona zmiana,
    \item $\text{sign}(\Delta x)$ - funkcja signum zwracająca znak zmiany.
\end{itemize}

\subsubsection{Wygładzanie wykładnicze}

Po przeprowadzeniu ograniczenia szybkości zmian, w kolejnym etapie stosowane jest wygładzanie wykładnicze \cite{hyndman_forecasting}:

\begin{equation}
x_{t+1} = x_t + (1-\alpha) \cdot \Delta x_{limited},
\end{equation}

gdzie:
\begin{itemize}
    \item $x_{t+1}$ - wygładzona wartość w chwili $t+1$,
    \item $x_t$ - wartość w chwili $t$,
    \item $\alpha = 0.8$ - współczynnik wygładzania (im wyższa wartość, tym większa waga wartości poprzedniej),
    \item $\Delta x_{limited}$ - ograniczona zmiana wartości.
\end{itemize}

\subsection{Model stanów urządzeń i przejść}
\label{subsec:model_stanow}

Generator implementuje deterministyczny model maszyny stanów z probabilistycznymi czasami trwania.

\subsubsection{Stany techniczne urządzeń}

Generator danych modeluje następujące stany techniczne:

\begin{itemize}
    \item \textbf{stan normalny} - prawidłowa praca urządzenia,
    \item \textbf{wczesne zużycie} - początkowe oznaki degradacji,
    \item \textbf{stan podkrytyczny} - znaczące pogorszenie parametrów,
    \item \textbf{stan krytyczny} - stan przed awarią,
    \item \textbf{naprawa} - okres nieaktywności urządzenia.
\end{itemize}

\subsubsection{Parametry czasowe stanów}

Każdy stan techniczny charakteryzuje się losowym czasem trwania z zakresu $[t_{min}, t_{max}]$, co zostało przedstawione w tabeli \ref{tab:parametry_stanow_sim}:

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|l|}
\hline
\textbf{Stan} & \textbf{Min. czas} & \textbf{Max. czas} & \textbf{Następny stan} \\
\hline
normalny & 24h & 7 dni & wczesne zużycie \\
wczesne zużycie & 12h & 48h & podkrytyczny \\
podkrytyczny & 6h & 24h & krytyczny \\
krytyczny & 1h & 6h & naprawa \\
naprawa & 2h & 4h & normalny \\
\hline
\end{tabular}
\caption{Parametry czasowe stanów urządzeń w symulatorze}
\label{tab:parametry_stanow_sim}
\end{table}

\newpage

\subsubsection{Deterministyczne przejścia stanów}

Generator wykorzystuje deterministyczne generowanie czasów trwania stanów na podstawie funkcji \textit{hash}:

\begin{equation}
t_{stan} = t_{min} + \textit{hash}(typ\_urzadzenia + stan + timestamp) \bmod (t_{\text{max}} - t_{min}),
\end{equation}

gdzie:
\begin{itemize}
    \item $t_{stan}$ - obliczony czas trwania aktualnego stanu,
    \item $t_{min}$ - minimalny czas trwania stanu,
    \item $t_{max}$ - maksymalny czas trwania stanu,
    \item $\textit{hash}(\cdot)$ - funkcja haszująca,
    \item $typ\_urzadzenia$ - typ urządzenia (pump, compressor, turbine),
    \item $stan$ - aktualny stan urządzenia,
    \item $timestamp$ - znacznik czasu rozpoczęcia stanu,
    \item $\bmod$ - operacja modulo.
\end{itemize}

Zapewnia to powtarzalność generowanych danych przy wykorzystaniu tego samego ziarna losowego.

\subsection{Algorytm generowania danych historycznych}
\label{subsec:algorytm_historycznych}

Generator implementuje algorytm generowania kompletnych szeregów czasowych historycznych z minutową rozdzielczością.

\subsubsection{Inicjalizacja deterministyczna}

Każdy typ urządzenia inicjalizowany jest z deterministycznym stanem początkowym:

\begin{equation}
stan_{poczatkowy} = \begin{cases}
\text{normalny} & \text{je\'sli } h(typ) \bmod 1.0 < 0.5 \\
\text{wczesne zu\.{z}ycie} & \text{je\'sli } 0.5 \leq h(typ) \bmod 1.0 < 0.8 \\
\text{podkrytyczny} & \text{w przeciwnym przypadku}
\end{cases},
\end{equation}

gdzie:
\begin{itemize}
    \item $stan_{poczatkowy}$ - początkowy stan urządzenia,
    \item $h(typ)$ - funkcja haszująca typu urządzenia,
    \item $typ$ - typ urządzenia (pump, compressor, turbine),
    \item $\bmod$ - operacja modulo.
\end{itemize}

\subsubsection{Iteracyjne generowanie danych}

Dla każdego kroku czasowego $t$ (minuty):

\begin{enumerate}
    \item aktualizacja czasu w stanie: $t_{stan} = t_{stan} + \Delta t,$ gdzie $t_{stan}$ to aktualny czas spędzony w stanie, a $\Delta t = 1$ minuta,
    \item obliczenie postępu: $progress = \textit{min}(1.0, t_{stan} / t_{trwania}),$ gdzie $t_{trwania}$ to całkowity czas trwania stanu,
    \item sprawdzenie konieczności przejścia stanu,
    \item generowanie wartości docelowych z rozkładu wielowymiarowego,
    \item zastosowanie wygładzania czasowego,
    \item zapis danych do pliku CSV.
\end{enumerate}

\subsubsection{Obsługa stanu naprawy}

Podczas stanu naprawy generator:
\begin{itemize}
    \item nie generuje wartości sensorycznych (wartości NULL),
    \item zachowuje informacje o stanie i czasie,
    \item po zakończeniu naprawy resetuje wartości do normalnych.
\end{itemize}

\subsubsection{Integracja z chmurą AWS}
\label{sec:integracja_aws}

System generatora danych został zaimplementowany jako w pełni bezserwerowa architektura w chmurze AWS, wykorzystująca funkcję AWS Lambda, usługę Amazon S3 oraz usługę Amazon SNS. Implementacja zapewnia skalowalność, niezawodność oraz efektywność kosztową przy minimalnych wymaganiach administracyjnych.

Generator czyta wcześniej wygenerowane pliki CSV z usługi S3 i generuje dane w odstępach minutowych.

\subsubsection{Architektura bezserwerowa}
\label{subsec:architektura_bezserwerowa}

Generator danych składa się z trzech głównych komponentów chmury AWS:

\begin{itemize}
    \item \textbf{usługa Amazon S3} - przechowywanie danych historycznych i metadanych konfiguracyjnych,
    \item \textbf{funkcja \mbox{AWS Lambda}} - funkcja wykonująca logikę publikowania danych w czasie rzeczywistym,
    \item \textbf{usługa \textbf{Amazon SNS}} - tematy publikacyjno-subskrypcyjne dla każdego typu sensora.
\end{itemize}

\subsubsection{Przechowywanie danych w Amazon S3}
\label{subsec:amazon_s3}

Generator wykorzystuje usługę \textbf{Amazon S3} jako centralne repozytorium dla danych historycznych wygenerowanych przez symulator lokalny.

\subsubsection{Struktura danych w S3}

Dane są organizowane w następującej strukturze:

\begin{itemize}
    \item \textbf{prefiks danych}: \textit{prod\_data/},
    \item \textbf{pliki CSV}: \textit{pump\_YYYYMMDD.csv}, \textit{compressor\_YYYYMMDD.csv}, \textit{turbine\_YYYYMMDD.csv},
    \item \textbf{metadane}: \textit{prod\_data/historical\_metadata.json}.
\end{itemize}

Poniższy plik reprezentuje format metadanych zawierający konfigurację systemu w formacie JSON, co zostało przedstawione na listingu \ref{lst:plik_metadanych}:

\begin{lstlisting}[caption=Przykładowy plik metadanych, label={lst:plik_metadanych}]
{
  "start_timestamp": 1672531200,
  "end_timestamp": 1675123199,
  "minute_resolution": 1,
  "equipment_types": ["Pump", "Compressor"],
  "sensor_types": ["temperature", "pressure", "vibration", "humidity"],
  "seed": 42,
  "files": {
    "Pump": "pump_20230101.csv",
    "Compressor": "compressor_20230101.csv" }}
\end{lstlisting}

\newpage

\subsubsection{Funkcja AWS Lambda}
\label{subsec:aws_lambda}

Główna logika systemu jest zaimplementowana jako funkcja AWS Lambda napisana w języku Python z wykorzystaniem bibliotek: boto3, pandas oraz pydantic \cite{pydantic_docs}. Generator wykorzystuje bibliotekę Pydantic do walidacji i serializacji danych, co zostało przedstawione na listingu \ref{lst:klasy_modeli_danych}.

\begin{lstlisting}[language=Python, caption=Klasy modeli danych, label={lst:klasy_modeli_danych}]
class SensorData(BaseModel):
    label: str
    timestamp: int
    event_key: str

class Temperature(SensorData):
    temperature: TemperatureData

class Pressure(SensorData):
    pressure: PressureData
\end{lstlisting}

\textbf{Algorytm publikowania danych} - funkcja AWS Lambda wykonuje następujący algorytm przy każdym wywołaniu. Funkcja implementuje algorytm wyszukiwania najbliższego czasowo rekordu, co zostało przedstawione na listingu \ref{lst:algorytm_wyszukiwania_rekordu}. 

\vspace{0.3em}

Składa się z następujących kroków:

\begin{enumerate}
    \item \textbf{ładowanie metadanych} z usługi S3 w celu określenia dostępnych plików z informacjami
    \item \textbf{ładowanie danych} dla każdego typu urządzenia z plików CSV
    \item \textbf{wyznaczenie aktualnego czasu} z zaokrągleniem do pełnej minuty
    \item \textbf{wyszukanie najbliższego rekordu} w danych historycznych dla każdego urządzenia
    \item \textbf{generowanie unikalnych kluczy} zdarzeń dla każdego urządzenia
    \item \textbf{publikowanie danych} do odpowiednich tematów usługi SNS dla każdego sensora
\end{enumerate}

\begin{lstlisting}[language=Python, caption=Algorytm wyszukiwania najbliższego rekordu, label={lst:algorytm_wyszukiwania_rekordu}]
def _find_closest_record(self, df, target_time):
    target_time_dt = pd.to_datetime(target_time)
    df['time_diff'] = abs(df['timestamp'] - target_time_dt)
    closest_record = df.loc[df['time_diff'].idxmin()]
    return closest_record
\end{lstlisting}

\subsubsection{Amazon SNS dla publikowania danych}
\label{subsec:amazon_sns}

Generator wykorzystuje system transportowania danych Amazon Simple Notification Service (SNS) do asynchronicznego publikowania danych sensorycznych w architekturze publish-subscribe. Każda wiadomość jest publikowana w formacie JSON zgodnym z modelem Pydantic.

\vspace{0.3em}

Dla każdego typu sensora utworzony jest dedykowany temat w usłudze SNS:

\begin{itemize}
    \item \textit{arn:aws:sns:eu-central-1:accountid:temperature-topic},
    \item \textit{arn:aws:sns:eu-central-1:accountid:pressure-topic},
    \item \textit{arn:aws:sns:eu-central-1:accountid:vibration-topic},
    \item \textit{arn:aws:sns:eu-central-1:accountid:humidity-topic}.
\end{itemize}

\newpage

Format publikowanych wiadomości do systemu SNS został przedstawiony na listingu \ref{lst:format_publikowanych_wiadomosci}.

\begin{lstlisting}[caption=Format publikowanych wiadomości, label={lst:format_publikowanych_wiadomosci}]
{
  "label": "pump",
  "timestamp": 1672531200,
  "event_key": "pump-1672531200",
  "temperature": {
    "temperature": 72.5
  }
}
\end{lstlisting}


Generator ten stanowi kluczowy element infrastruktury testowej, umożliwiając kompleksową walidację opracowanego systemu analizy danych bez konieczności dostępu do rzeczywistych instalacji przemysłowych oraz zapewniając pełną integrację z ekosystemem chmury AWS.